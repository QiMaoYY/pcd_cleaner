#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
步骤1+2 合并版：
从 <地图根目录>/<地图名>/pointcloud_original.pcd 读取原始点云
1) 去除屋顶（z > ceiling）
2) 提取地面（RANSAC），计算 ground_z_range
3) 去除地面以下点（z < ground_z_min - 0.1）
4) 输出：
   - <地图根目录>/<地图名>/range_z.json
   - <地图根目录>/<地图名>/pointcloud_tmp.pcd
5) 调用 pcd2pgm + map_saver 生成：
   - <地图根目录>/<地图名>/map2d_init.pgm
   - <地图根目录>/<地图名>/map2d_init.yaml（image 修正为绝对路径）
"""

import argparse
import json
import os
import shutil
import signal
import subprocess
import sys
import time

import numpy as np
import open3d as o3d
import rospy
import yaml
from nav_msgs.msg import OccupancyGrid


class PreprocessAndMap2D:
    def __init__(self, map_root: str, map_name: str, ceiling: float):
        self.map_root = os.path.abspath(os.path.expanduser(map_root))
        self.map_name = map_name
        self.map_dir = os.path.join(self.map_root, self.map_name)
        self.ceiling = float(ceiling)

        self.input_pcd = os.path.join(self.map_dir, "pointcloud_original.pcd")
        self.tmp_pcd = os.path.join(self.map_dir, "pointcloud_tmp.pcd")
        self.range_json = os.path.join(self.map_dir, "range_z.json")

        self.map_prefix = os.path.join(self.map_dir, "map2d_init")
        self.map_pgm = self.map_prefix + ".pgm"
        self.map_yaml = self.map_prefix + ".yaml"

        self.ground_z_range = None
        self.launch_process = None
        self.map_received = False

    def ensure_dir(self):
        os.makedirs(self.map_dir, exist_ok=True)

    def load_pcd(self) -> o3d.geometry.PointCloud:
        if not os.path.exists(self.input_pcd):
            raise FileNotFoundError(f"未找到输入点云：{self.input_pcd}")
        pcd = o3d.io.read_point_cloud(self.input_pcd)
        if pcd.is_empty():
            raise RuntimeError(f"点云为空：{self.input_pcd}")
        return pcd

    @staticmethod
    def _pcd_from_mask(pcd: o3d.geometry.PointCloud, keep_mask: np.ndarray) -> o3d.geometry.PointCloud:
        points = np.asarray(pcd.points)
        out = o3d.geometry.PointCloud()
        out.points = o3d.utility.Vector3dVector(points[keep_mask])
        if pcd.has_colors():
            colors = np.asarray(pcd.colors)
            out.colors = o3d.utility.Vector3dVector(colors[keep_mask])
        return out

    def remove_ceiling(self, pcd: o3d.geometry.PointCloud) -> o3d.geometry.PointCloud:
        pts = np.asarray(pcd.points)
        keep = pts[:, 2] <= self.ceiling
        return self._pcd_from_mask(pcd, keep)

    def extract_ground_range(self, pcd: o3d.geometry.PointCloud, distance_threshold=0.05, ransac_n=3, num_iterations=1000, percentile=95):
        pts = np.asarray(pcd.points)
        neg_mask = pts[:, 2] < 0
        neg_pts = pts[neg_mask]
        if neg_pts.shape[0] == 0:
            raise RuntimeError("未找到 z<0 的点，无法提取地面")

        neg_pcd = o3d.geometry.PointCloud()
        neg_pcd.points = o3d.utility.Vector3dVector(neg_pts)
        _, inliers = neg_pcd.segment_plane(
            distance_threshold=distance_threshold,
            ransac_n=ransac_n,
            num_iterations=num_iterations,
        )
        if len(inliers) == 0:
            raise RuntimeError("地面RANSAC未找到内点")

        ground_z = neg_pts[inliers][:, 2]
        z_min = float(np.percentile(ground_z, (100 - percentile) / 2))
        z_max = float(np.percentile(ground_z, percentile + (100 - percentile) / 2))
        z_mean = float(ground_z.mean())
        z_std = float(ground_z.std())
        self.ground_z_range = {"min": z_min, "max": z_max, "mean": z_mean, "std": z_std}

    def remove_below_ground(self, pcd: o3d.geometry.PointCloud, margin=0.1) -> o3d.geometry.PointCloud:
        if not self.ground_z_range:
            raise RuntimeError("ground_z_range 未生成")
        thr = self.ground_z_range["min"] - float(margin)
        pts = np.asarray(pcd.points)
        keep = pts[:, 2] >= thr
        return self._pcd_from_mask(pcd, keep)

    def save_outputs(self, tmp_pcd: o3d.geometry.PointCloud):
        o3d.io.write_point_cloud(self.tmp_pcd, tmp_pcd)
        data = {
            "ground_z_range": self.ground_z_range,
            "ceiling_z_threshold": self.ceiling,
            "input_pcd": self.input_pcd,
            "output_pcd": self.tmp_pcd,
        }
        with open(self.range_json, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

    def _generate_launch_file(self, launch_path: str, thre_z_min: float, thre_z_max: float):
        file_dir = self.map_dir + "/"
        file_name = "pointcloud_tmp"
        content = f"""<!-- Auto-generated by pcd_cleaner -->
<launch>
<node pkg="pcd2pgm" name="pcd2pgm" type="pcd2pgm" output="screen">
  <param name="file_directory" value="{file_dir}" />
  <param name="file_name" value="{file_name}" />
  <param name="thre_z_min" value="{thre_z_min:.4f}" />
  <param name="thre_z_max" value="{thre_z_max:.4f}" />
  <param name="flag_pass_through" value="0" />
  <param name="thre_radius" value="0.5" />
  <param name="thres_point_count" value="10" />
  <param name="map_resolution" value="0.05" />
  <param name="map_topic_name" value="map" />
  <param name="map_frame_id" value="map" />
  <param name="yaw_deg" value="0.0" />
  <param name="flip_x" value="false" />
  <param name="flip_y" value="false" />
  <param name="swap_xy" value="false" />
</node>
</launch>
"""
        with open(launch_path, "w", encoding="utf-8") as f:
            f.write(content)

    def _map_cb(self, msg: OccupancyGrid):
        if not self.map_received:
            self.map_received = True

    def _wait_for_map(self, timeout_sec: int = 180) -> bool:
        rospy.Subscriber("/map", OccupancyGrid, self._map_cb)
        start = time.time()
        rate = rospy.Rate(10)
        while not rospy.is_shutdown() and not self.map_received:
            if time.time() - start > timeout_sec:
                return False
            rate.sleep()
        time.sleep(1)
        return self.map_received

    def _cleanup_launch(self):
        if self.launch_process and self.launch_process.poll() is None:
            self.launch_process.terminate()
            try:
                self.launch_process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                self.launch_process.kill()

    def _fix_map_yaml_image_abs(self):
        if not os.path.exists(self.map_yaml) or not os.path.exists(self.map_pgm):
            return
        with open(self.map_yaml, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f) or {}
        data["image"] = os.path.abspath(self.map_pgm)
        with open(self.map_yaml, "w", encoding="utf-8") as f:
            yaml.safe_dump(data, f, default_flow_style=False, sort_keys=False, allow_unicode=True)

    def run(self) -> int:
        self.ensure_dir()

        # 点云预处理
        pcd = self.load_pcd()
        pcd_no_ceiling = self.remove_ceiling(pcd)
        self.extract_ground_range(pcd_no_ceiling)
        tmp = self.remove_below_ground(pcd_no_ceiling, margin=0.1)
        self.save_outputs(tmp)

        # 生成 2D 地图
        thre_z_min = float(self.ground_z_range["max"]) + 0.1
        thre_z_max = float(self.ceiling)

        # 临时 launch
        launch_path = os.path.join(self.map_dir, f"_pcd2pgm_{self.map_name}.launch")
        self._generate_launch_file(launch_path, thre_z_min, thre_z_max)

        try:
            rospy.init_node("pcd_cleaner_preprocess_and_map2d", anonymous=True)
        except rospy.exceptions.ROSException:
            pass

        self.map_received = False
        self.launch_process = subprocess.Popen(["roslaunch", launch_path])

        ok = self._wait_for_map(timeout_sec=180)
        if not ok:
            self._cleanup_launch()
            return 1

        # 保存地图到 map2d_init.*
        # map_saver 会生成 <prefix>.pgm / <prefix>.yaml
        subprocess.run(["rosrun", "map_server", "map_saver", "-f", self.map_prefix], check=True, timeout=30)

        self._cleanup_launch()
        if os.path.exists(launch_path):
            os.remove(launch_path)

        # 修正 image 为绝对路径（与你现有 init.yaml 格式一致）
        self._fix_map_yaml_image_abs()
        return 0


def main() -> int:
    parser = argparse.ArgumentParser(description="点云预处理 + 生成2D栅格地图（合并版）")
    parser.add_argument("--map-root", "-r", default="/media/data/slam_ws/src/kuavo_slam/maps", help="地图根目录")
    parser.add_argument("--map-name", "-n", default="map_demo", help="地图名称（子目录名）")
    parser.add_argument("--ceiling", "-c", type=float, default=0.8, help="屋顶高度阈值（米）")
    args = parser.parse_args()

    app = PreprocessAndMap2D(args.map_root, args.map_name, args.ceiling)

    def _sigint(sig, frame):
        app._cleanup_launch()
        sys.exit(0)

    signal.signal(signal.SIGINT, _sigint)
    return app.run()


if __name__ == "__main__":
    sys.exit(main())


